<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>MiniPID.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">rc-app</a> &gt; <a href="../index.html" class="el_bundle">rc-action</a> &gt; <a href="index.source.html" class="el_package">stormbots</a> &gt; <span class="el_source">MiniPID.java</span></div><h1>MiniPID.java</h1><pre class="source lang-java linenums">package stormbots;
/**
* Small, easy to use PID implementation with advanced controller capability.&lt;br&gt; 
* Minimal usage:&lt;br&gt;
* MiniPID pid = new MiniPID(p,i,d); &lt;br&gt;
* ...looping code...{ &lt;br&gt;
*   output= pid.getOutput(sensorvalue,target); &lt;br&gt;
* }
* 
* @see http://brettbeauregard.com/blog/2011/04/improving-the-beginners-pid-direction/improving-the-beginners-pid-introduction
*/
public class MiniPID{
	//**********************************
	// Class private variables
	//**********************************

<span class="nc" id="L17">	private double P=0;</span>
<span class="nc" id="L18">	private double I=0;</span>
<span class="nc" id="L19">	private double D=0;</span>
<span class="nc" id="L20">	private double F=0;</span>

<span class="nc" id="L22">	private double maxIOutput=0;</span>
<span class="nc" id="L23">	private double maxError=0;</span>
<span class="nc" id="L24">	private double errorSum=0;</span>

<span class="nc" id="L26">	private double maxOutput=0; </span>
<span class="nc" id="L27">	private double minOutput=0;</span>

<span class="nc" id="L29">	private double setpoint=0;</span>

<span class="nc" id="L31">	private double lastActual=0;</span>

<span class="nc" id="L33">	private boolean firstRun=true;</span>
<span class="nc" id="L34">	private boolean reversed=false;</span>

<span class="nc" id="L36">	private double outputRampRate=0;</span>
<span class="nc" id="L37">	private double lastOutput=0;</span>

<span class="nc" id="L39">	private double outputFilter=0;</span>

<span class="nc" id="L41">	private double setpointRange=0;</span>

	//**********************************
	// Constructor functions
	//**********************************
	
	/**
	 * Create a MiniPID class object. 
	 * See setP, setI, setD methods for more detailed parameters.
	 * @param p Proportional gain. Large if large difference between setpoint and target. 
	 * @param i Integral gain.  Becomes large if setpoint cannot reach target quickly. 
	 * @param d Derivative gain. Responds quickly to large changes in error. Small values prevents P and I terms from causing overshoot.
	 */
<span class="nc" id="L54">	public MiniPID(double p, double i, double d){</span>
<span class="nc" id="L55">		P=p; I=i; D=d;</span>
<span class="nc" id="L56">		checkSigns();</span>
<span class="nc" id="L57">		}</span>

	/**
	 * Create a MiniPID class object. 
	 * See setP, setI, setD, setF methods for more detailed parameters.
	 * @param p Proportional gain. Large if large difference between setpoint and target. 
	 * @param i Integral gain.  Becomes large if setpoint cannot reach target quickly. 
	 * @param d Derivative gain. Responds quickly to large changes in error. Small values prevents P and I terms from causing overshoot.
	 * @param f Feed-forward gain. Open loop &quot;best guess&quot; for the output should be. Only useful if setpoint represents a rate.
	 */
<span class="nc" id="L67">	public MiniPID(double p, double i, double d, double f){</span>
<span class="nc" id="L68">		P=p; I=i; D=d; F=f;</span>
<span class="nc" id="L69">		checkSigns();</span>
<span class="nc" id="L70">		}</span>

	//**********************************
	// Configuration functions
	//**********************************
	/**
	 * Configure the Proportional gain parameter. &lt;br&gt;
	 * This responds quickly to changes in setpoint, and provides most of the initial driving force
	 * to make corrections. &lt;br&gt;
	 * Some systems can be used with only a P gain, and many can be operated with only PI.&lt;br&gt;
	 * For position based controllers, this is the first parameter to tune, with I second. &lt;br&gt;
	 * For rate controlled systems, this is often the second after F.
	 *  
	 * @param p Proportional gain. Affects output according to &lt;b&gt;output+=P*(setpoint-current_value)&lt;/b&gt;
	 */
	public void setP(double p){
<span class="nc" id="L86">		P=p;</span>
<span class="nc" id="L87">		checkSigns();</span>
<span class="nc" id="L88">	}</span>

	/**
	 * Changes the I parameter &lt;br&gt;
	 * This is used for overcoming disturbances, and ensuring that the controller always gets to the control mode. 
	 * Typically tuned second for &quot;Position&quot; based modes, and third for &quot;Rate&quot; or continuous based modes. &lt;br&gt;
	 * Affects output through &lt;b&gt;output+=previous_errors*Igain ;previous_errors+=current_error&lt;/b&gt;
	 * 
	 * @see {@link #setMaxIOutput(double) setMaxIOutput} for how to restrict
	 *
	 * @param i New gain value for the Integral term
	 */
	public void setI(double i){
<span class="nc bnc" id="L101" title="All 2 branches missed.">		if(I!=0){</span>
<span class="nc" id="L102">			errorSum=errorSum*I/i;</span>
			}
<span class="nc bnc" id="L104" title="All 2 branches missed.">		if(maxIOutput!=0){</span>
<span class="nc" id="L105">			maxError=maxIOutput/i;</span>
		}
<span class="nc" id="L107">		I=i;</span>
<span class="nc" id="L108">		checkSigns();</span>
		 // Implementation note: 
		 // This Scales the accumulated error to avoid output errors. 
		 // As an example doubling the I term cuts the accumulated error in half, which results in the 
		 // output change due to the I term constant during the transition. 
<span class="nc" id="L113">	}</span>

	/**
	 * Changes the D parameter &lt;br&gt;
	 * This has two primary effects:
	 * &lt;list&gt;
	 * &lt;li&gt; Adds a &quot;startup kick&quot; and speeds up system response during setpoint changes
	 * &lt;li&gt; Adds &quot;drag&quot; and slows the system when moving toward the target
	 * &lt;/list&gt;
	 * A small D value can be useful for both improving response times, and preventing overshoot.
	 * However, in many systems a large D value will cause significant instability, particularly 
	 * for large setpoint changes.
	 * &lt;br&gt;
	 * Affects output through &lt;b&gt;output += -D*(current_input_value - last_input_value)&lt;/b&gt;
	 *
	 * @param d New gain value for the Derivative term
	 */
	public void setD(double d){
<span class="nc" id="L131">		D=d;</span>
<span class="nc" id="L132">		checkSigns();</span>
<span class="nc" id="L133">		}</span>

	/**
	 * Configure the FeedForward parameter. &lt;br&gt;
	 * This is excellent for velocity, rate, and other  continuous control modes where you can 
	 * expect a rough output value based solely on the setpoint.&lt;br&gt;
	 * Should not be used in &quot;position&quot; based control modes.&lt;br&gt;
	 * Affects output according to &lt;b&gt;output+=F*Setpoint&lt;/b&gt;. Note, that a F-only system is actually open loop.
	 * 
	 * @param f Feed forward gain. 
	 */
	public void setF(double f){
<span class="nc" id="L145">		F=f;</span>
<span class="nc" id="L146">		checkSigns();</span>
<span class="nc" id="L147">	}</span>

	/** 
	 * Configure the PID object.
	 * See setP, setI, setD methods for more detailed parameters.
	 * @param p Proportional gain. Large if large difference between setpoint and target. 
	 * @param i Integral gain.  Becomes large if setpoint cannot reach target quickly. 
	 * @param d Derivative gain. Responds quickly to large changes in error. Small values prevents P and I terms from causing overshoot.
	 */
	public void setPID(double p, double i, double d){
<span class="nc" id="L157">		P=p;D=d;</span>
		//Note: the I term has additional calculations, so we need to use it's 
		//specific method for setting it.
<span class="nc" id="L160">		setI(i);</span>
<span class="nc" id="L161">		checkSigns();</span>
<span class="nc" id="L162">	}</span>

	/** 
	 * Configure the PID object.
	 * See setP, setI, setD, setF methods for more detailed parameters.
	 * @param p Proportional gain. Large if large difference between setpoint and target. 
	 * @param i Integral gain.  Becomes large if setpoint cannot reach target quickly. 
	 * @param d Derivative gain. Responds quickly to large changes in error. Small values prevents P and I terms from causing overshoot.
	 * @param f Feed-forward gain. Open loop &quot;best guess&quot; for the output should be. Only useful if setpoint represents a rate.
	 */
	public void setPID(double p, double i, double d,double f){
<span class="nc" id="L173">		P=p;D=d;F=f;</span>
		//Note: the I term has additional calculations, so we need to use it's 
		//specific method for setting it.
<span class="nc" id="L176">		setI(i);</span>
<span class="nc" id="L177">		checkSigns();</span>
<span class="nc" id="L178">	}</span>

	/**
	 * Set the maximum output value contributed by the I component of the system
	 * This can be used to prevent large windup issues and make tuning simpler
	 * @param maximum. Units are the same as the expected output value
	 */
	public void setMaxIOutput(double maximum){
		// Internally maxError and Izone are similar, but scaled for different purposes. 
		// The maxError is generated for simplifying math, since calculations against 
		// the max error are far more common than changing the I term or Izone. 
<span class="nc" id="L189">		maxIOutput=maximum;</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">		if(I!=0){</span>
<span class="nc" id="L191">			maxError=maxIOutput/I;</span>
		}
<span class="nc" id="L193">	}</span>

	/**
	 * Specify a maximum output range. &lt;br&gt;
	 * When one input is specified, output range is configured to 
	 * &lt;b&gt;[-output, output]&lt;/b&gt;
	 * @param output
	 */
	public void setOutputLimits(double output){
<span class="nc" id="L202">		setOutputLimits(-output,output);</span>
<span class="nc" id="L203">	}</span>

	/**
	 * Specify a  maximum output.
	 * When two inputs specified, output range is configured to 
	 * &lt;b&gt;[minimum, maximum]&lt;/b&gt;
	 * @param minimum possible output value
	 * @param maximum possible output value
	 */
	public void setOutputLimits(double minimum,double maximum){
<span class="nc bnc" id="L213" title="All 2 branches missed.">		if(maximum&lt;minimum)return;</span>
<span class="nc" id="L214">		maxOutput=maximum;</span>
<span class="nc" id="L215">		minOutput=minimum;</span>

		// Ensure the bounds of the I term are within the bounds of the allowable output swing
<span class="nc bnc" id="L218" title="All 4 branches missed.">		if(maxIOutput==0 || maxIOutput&gt;(maximum-minimum) ){</span>
<span class="nc" id="L219">			setMaxIOutput(maximum-minimum);</span>
		}
<span class="nc" id="L221">	}</span>

	/** 
	 * Set the operating direction of the PID controller
	 * @param reversed Set true to reverse PID output
	 */
	public void  setDirection(boolean reversed){
<span class="nc" id="L228">		this.reversed=reversed;</span>
<span class="nc" id="L229">	}</span>

	//**********************************
	// Primary operating functions
	//**********************************

	/**
	 * Configure setpoint for the PID calculations&lt;br&gt;
	 * This represents the target for the PID system's, such as a 
	 * position, velocity, or angle. &lt;br&gt;
	 * @see MiniPID#getOutput(actual) &lt;br&gt;
	 * @param setpoint
	 */
	public void setSetpoint(double setpoint){
<span class="nc" id="L243">		this.setpoint=setpoint;</span>
<span class="nc" id="L244">	}</span>

	/**
	 * Calculate the output value for the current PID cycle.&lt;br&gt;
	 * @param actual The monitored value, typically as a sensor input.
	 * @param setpoint The target value for the system
	 * @return calculated output value for driving the system
	 */
	public double getOutput(double actual, double setpoint){
		double output;
		double Poutput;
		double Ioutput;
		double Doutput;
		double Foutput;

<span class="nc" id="L259">		this.setpoint=setpoint;</span>

		// Ramp the setpoint used for calculations if user has opted to do so
<span class="nc bnc" id="L262" title="All 2 branches missed.">		if(setpointRange!=0){</span>
<span class="nc" id="L263">			setpoint=constrain(setpoint,actual-setpointRange,actual+setpointRange);</span>
		}

		// Do the simple parts of the calculations
<span class="nc" id="L267">		double error=setpoint-actual;</span>

		// Calculate F output. Notice, this depends only on the setpoint, and not the error. 
<span class="nc" id="L270">		Foutput=F*setpoint;</span>

		// Calculate P term
<span class="nc" id="L273">		Poutput=P*error;   </span>

		// If this is our first time running this, we don't actually _have_ a previous input or output. 
		// For sensor, sanely assume it was exactly where it is now.
		// For last output, we can assume it's the current time-independent outputs. 
<span class="nc bnc" id="L278" title="All 2 branches missed.">		if(firstRun){</span>
<span class="nc" id="L279">			lastActual=actual;</span>
<span class="nc" id="L280">			lastOutput=Poutput+Foutput;</span>
<span class="nc" id="L281">			firstRun=false;</span>
		}

		// Calculate D Term
		// Note, this is negative. This actually &quot;slows&quot; the system if it's doing
		// the correct thing, and small values helps prevent output spikes and overshoot 
<span class="nc" id="L287">		Doutput= -D*(actual-lastActual);</span>
<span class="nc" id="L288">		lastActual=actual;</span>

		// The Iterm is more complex. There's several things to factor in to make it easier to deal with.
		// 1. maxIoutput restricts the amount of output contributed by the Iterm.
		// 2. prevent windup by not increasing errorSum if we're already running against our max Ioutput
		// 3. prevent windup by not increasing errorSum if output is output=maxOutput    
<span class="nc" id="L294">		Ioutput=I*errorSum;</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">		if(maxIOutput!=0){</span>
<span class="nc" id="L296">			Ioutput=constrain(Ioutput,-maxIOutput,maxIOutput); </span>
		}    

		// And, finally, we can just add the terms up
<span class="nc" id="L300">		output=Foutput + Poutput + Ioutput + Doutput;</span>

		// Figure out what we're doing with the error.
<span class="nc bnc" id="L303" title="All 4 branches missed.">		if(minOutput!=maxOutput &amp;&amp; !bounded(output, minOutput,maxOutput) ){</span>
<span class="nc" id="L304">			errorSum=error; </span>
			// reset the error sum to a sane level
			// Setting to current error ensures a smooth transition when the P term 
			// decreases enough for the I term to start acting upon the controller
			// From that point the I term will build up as would be expected
		}
<span class="nc bnc" id="L310" title="All 4 branches missed.">		else if(outputRampRate!=0 &amp;&amp; !bounded(output, lastOutput-outputRampRate,lastOutput+outputRampRate) ){</span>
<span class="nc" id="L311">			errorSum=error; </span>
		}
<span class="nc bnc" id="L313" title="All 2 branches missed.">		else if(maxIOutput!=0){</span>
<span class="nc" id="L314">			errorSum=constrain(errorSum+error,-maxError,maxError);</span>
			// In addition to output limiting directly, we also want to prevent I term 
			// buildup, so restrict the error directly
		}
		else{
<span class="nc" id="L319">			errorSum+=error;</span>
		}

		// Restrict output to our specified output and ramp limits
<span class="nc bnc" id="L323" title="All 2 branches missed.">		if(outputRampRate!=0){</span>
<span class="nc" id="L324">			output=constrain(output, lastOutput-outputRampRate,lastOutput+outputRampRate);</span>
		}
<span class="nc bnc" id="L326" title="All 2 branches missed.">		if(minOutput!=maxOutput){ </span>
<span class="nc" id="L327">			output=constrain(output, minOutput,maxOutput);</span>
			}
<span class="nc bnc" id="L329" title="All 2 branches missed.">		if(outputFilter!=0){</span>
<span class="nc" id="L330">			output=lastOutput*outputFilter+output*(1-outputFilter);</span>
		}

		// Get a test printline with lots of details about the internal 
		// calculations. This can be useful for debugging. 
		// System.out.printf(&quot;Final output %5.2f [ %5.2f, %5.2f , %5.2f  ], eSum %.2f\n&quot;,output,Poutput, Ioutput, Doutput,errorSum );
		// System.out.printf(&quot;%5.2f\t%5.2f\t%5.2f\t%5.2f\n&quot;,output,Poutput, Ioutput, Doutput );

<span class="nc" id="L338">		lastOutput=output;</span>
<span class="nc" id="L339">		return output;</span>
	}

	/**
	 * Calculate the output value for the current PID cycle.&lt;br&gt;
	 * In no-parameter mode, this uses the last sensor value, 
	 * and last setpoint value. &lt;br&gt;
	 * Not typically useful, and use of parameter modes is suggested. &lt;br&gt;
	 * @return calculated output value for driving the system
	 */
	public double getOutput(){
<span class="nc" id="L350">		return getOutput(lastActual,setpoint);</span>
	}

	/**
	 * Calculate the output value for the current PID cycle.&lt;br&gt;
	 * In one parameter mode, the last configured setpoint will be used.&lt;br&gt;
	 * @see MiniPID#setSetpoint()
	 * @param actual The monitored value, typically as a sensor input.
	 * @param setpoint The target value for the system
	 * @return calculated output value for driving the system
	 */
	public double getOutput(double actual){
<span class="nc" id="L362">		return getOutput(actual,setpoint);</span>
	}

	/**
	 * Resets the controller. This erases the I term buildup, and removes 
	 * D gain on the next loop.&lt;br&gt;
	 * This should be used any time the PID is disabled or inactive for extended
	 * duration, and the controlled portion of the system may have changed due to
	 * external forces.
	 */
	public void reset(){
<span class="nc" id="L373">		firstRun=true;</span>
<span class="nc" id="L374">		errorSum=0;</span>
<span class="nc" id="L375">	}</span>

	/**
     * Set the maximum rate the output can increase per cycle.&lt;br&gt;
     * This can prevent sharp jumps in output when changing setpoints or 
     * enabling a PID system, which might cause stress on physical or electrical
     * systems.  &lt;br&gt;
     * Can be very useful for fast-reacting control loops, such as ones 
     * with large P or D values and feed-forward systems.
     * 
	 * @param rate, with units being the same as the output
	 */
	public void setOutputRampRate(double rate){
<span class="nc" id="L388">		outputRampRate=rate;</span>
<span class="nc" id="L389">	}</span>

	/** 
     * Set a limit on how far the setpoint can be from the current position
	 * &lt;br&gt;Can simplify tuning by helping tuning over a small range applies to a much larger range. 
	 * &lt;br&gt;This limits the reactivity of P term, and restricts impact of large D term
	 * during large setpoint adjustments. Increases lag and I term if range is too small.
	 * @param range, with units being the same as the expected sensor range. 
	 */
	public void setSetpointRange(double range){
<span class="nc" id="L399">		setpointRange=range;</span>
<span class="nc" id="L400">	}</span>

	/**
     * Set a filter on the output to reduce sharp oscillations. &lt;br&gt;
	 * 0.1 is likely a sane starting value. Larger values use historical data
	 * more heavily, with low values weigh newer data. 0 will disable, filtering, and use 
	 * only the most recent value. &lt;br&gt;
	 * Increasing the filter strength will P and D oscillations, but force larger I 
	 * values and increase I term overshoot.&lt;br&gt;
	 * Uses an exponential wieghted rolling sum filter, according to a simple &lt;br&gt;
	 * &lt;pre&gt;output*(1-strength)*sum(0..n){output*strength^n}&lt;/pre&gt; algorithm.
	 * @param output valid between [0..1), meaning [current output only.. historical output only)
	 */
	public void setOutputFilter(double strength){
<span class="nc bnc" id="L414" title="All 4 branches missed.">		if(strength==0 || bounded(strength,0,1)){</span>
<span class="nc" id="L415">		outputFilter=strength;</span>
		}
<span class="nc" id="L417">	}</span>

	//**************************************
	// Helper functions
	//**************************************

	/**
	 * Forces a value into a specific range
	 * @param value input value
	 * @param min maximum returned value
	 * @param max minimum value in range
	 * @return Value if it's within provided range, min or max otherwise 
	 */
	private double constrain(double value, double min, double max){
<span class="nc bnc" id="L431" title="All 2 branches missed.">		if(value &gt; max){ return max;}</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">		if(value &lt; min){ return min;}</span>
<span class="nc" id="L433">		return value;</span>
	}  

	/**
	 * Test if the value is within the min and max, inclusive
	 * @param value to test
	 * @param min Minimum value of range
	 * @param max Maximum value of range
	 * @return true if value is within range, false otherwise
	 */
	private boolean bounded(double value, double min, double max){
		// Note, this is an inclusive range. This is so tests like
		// `bounded(constrain(0,0,1),0,1)` will return false.
		// This is more helpful for determining edge-case behaviour
		// than &lt;= is.
<span class="nc bnc" id="L448" title="All 4 branches missed.">		return (min&lt;value) &amp;&amp; (value&lt;max);</span>
	}

	/**
	 * To operate correctly, all PID parameters require the same sign
	 * This should align with the {@literal}reversed value
	 */
	private void checkSigns(){
<span class="nc bnc" id="L456" title="All 2 branches missed.">		if(reversed){  // all values should be below zero</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">			if(P&gt;0) P*=-1;</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">			if(I&gt;0) I*=-1;</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">			if(D&gt;0) D*=-1;</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">			if(F&gt;0) F*=-1;</span>
		}
		else{  // all values should be above zero
<span class="nc bnc" id="L463" title="All 2 branches missed.">			if(P&lt;0) P*=-1;</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">			if(I&lt;0) I*=-1;</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">			if(D&lt;0) D*=-1;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">			if(F&lt;0) F*=-1;</span>
		}
<span class="nc" id="L468">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>